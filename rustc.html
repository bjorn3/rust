<meta charset="utf-8">
<script type="module">
    const FILETYPE_UNKNOWN = 0;
    const FILETYPE_DIRECTORY = 3;
    const FILETYPE_REGULAR_FILE = 4;

    class File {
        constructor(data) {
            console.log(data);
            this.data = new Uint8Array(data);
        }

        get size() {
            return BigInt(this.data.byteLength);
        }

        open() {
            return new OpenFile(this);
        }

        stat() {
            return {
                dev: 0n,
                ino: 0n,
                file_type: this.file_type,
                nlink: 0n,
                size: this.size,
                atim: 0n,
                mtim: 0n,
                ctim: 0n,
            };
        }
    }

    class OpenFile {
        file_type = FILETYPE_REGULAR_FILE;

        constructor(file) {
            this.file = file;
            this.file_pos = 0;
        }

        get size() {
            return this.file.size;
        }

        read(len) {
            if (this.file_pos < this.file.data.byteLength) {
                let slice = this.file.data.slice(this.file_pos, this.file_pos + len);
                this.file_pos += slice.length;
                return [slice, 0];
            } else {
                return [[], 0];
            }
        }

        write(buffer) {
            return -1;
        }

        stat() {
            return this.file.stat();
        }
    }

    class Directory {
        file_type = FILETYPE_DIRECTORY;

        constructor(contents) {
            this.directory = contents;
        }

        open() {
            return this;
        }

        get_entry_for_path(path) {
            let entry = this;
            for (let component of path.split("/")) {
                if (component == "") break;
                if (entry.directory[component] != undefined) {
                    entry = entry.directory[component];
                } else {
                    console.log(component);
                    return null;
                }
            }
            return entry;
        }
    }

    class PreopenDirectory extends Directory {
        constructor(name, contents) {
            super(contents);
            this.prestat_name = new TextEncoder("utf-8").encode(name);
        }
    }

    class Stdio {
        file_type = FILETYPE_UNKNOWN;

        read(len) {
            throw "unimplemented read from stdio";
        }

        write(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }
    }

    (async function () {
        document.body.style.fontFamily = "monospace";
        document.body.style.whiteSpace = "pre";
        document.body.innerText = "Downloading";
        let wasm = await WebAssembly.compileStreaming(fetch("/target/wasm32-wasi/release/rustc_binary.wasm"));
        //let wasm = await WebAssembly.compileStreaming(fetch("/rust_out.wasm"));
        document.body.innerText = "Instantiating";

        function write_le_u32(buf, ptr, num) {
            buf[ptr] = num;
            buf[ptr + 1] = num >> 8;
            buf[ptr + 2] = num >> 16;
            buf[ptr + 3] = num >> 24;
        }

        function write_le_u64(buf, ptr, num) {
            buf[ptr] = Number(num);
            buf[ptr + 1] = Number(num >> 8n);
            buf[ptr + 2] = Number(num >> 16n);
            buf[ptr + 3] = Number(num >> 24n);
            buf[ptr + 4] = Number(num >> 32n);
            buf[ptr + 5] = Number(num >> 40n);
            buf[ptr + 6] = Number(num >> 48n);
            buf[ptr + 7] = Number(num >> 56n);
        }

        function fd_err() {
            return -1;
        }

        function read_stdio() {
            throw "unimplemented read_stdio";
        }

        function write_stdio(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }

        function new_directory(name, contents) {
            return new Directory(name, contents);
        }

        async function load_external_file(path) {
            return new File(await (await (await fetch(path)).blob()).arrayBuffer());
        }

        let args = ["rustc", "./hello.rs", "--sysroot", "/sysroot", "--target", "x86_64-unknown-linux-gnu", "-Cpanic=abort", "-Ccodegen-units=1"];
        let env = ["RUSTC_LOG=trace"];
        let fds = [
            new Stdio(),
            new Stdio(),
            new Stdio(),
            new PreopenDirectory(".", {
                "hello.rs": new File(new TextEncoder("utf-8").encode(`#![feature(start)]
                #![no_std]
                #[panic_handler]
                fn panic_handler(_: &core::panic::PanicInfo) -> ! {
                    loop {}
                }
                #[start]
                fn start(argc: isize, argv: *const *const u8) -> isize { 0 }`)),
            }),
            new PreopenDirectory("/sysroot", {
                "lib": new Directory({
                    "rustlib": new Directory({
                        "wasm32-wasi": new Directory({
                            "lib": new Directory({}),
                        }),
                        "x86_64-unknown-linux-gnu": new Directory({
                            "lib": new Directory({
                                "libcore-b4a7d25c83ac0d14.rmeta": await load_external_file("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcore-b4a7d25c83ac0d14.rmeta"),
                                "librustc_std_workspace_core-18038143f92ab7ad.rmeta": await load_external_file("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/librustc_std_workspace_core-18038143f92ab7ad.rmeta"),
                                "libcompiler_builtins-f0b22b2b55b20afb.rmeta": await load_external_file("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcompiler_builtins-f0b22b2b55b20afb.rmeta"),
                            }),
                        }),
                    }),
                }),
            }),
        ];

        let inst = await WebAssembly.instantiate(wasm, {
            "wasi_snapshot_preview1": {
                proc_exit() { console.log("proc_exit"); },
                random_get() { console.log("random_get"); },
                args_sizes_get(argc, argv_buf_size) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("args_sizes_get(", argc, ", ", argv_buf_size, ")");
                    buffer.setUint32(argc, args.length, true);
                    let buf_size = 0;
                    for (let arg of args) {
                        buf_size += arg.length + 1;
                    }
                    buffer.setUint32(argv_buf_size, buf_size, true);
                    console.log(buffer.getUint32(argc, true), buffer.getUint32(argv_buf_size, true));
                    return 0;
                },
                args_get(argv, argv_buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("args_get(", argv, ", ", argv_buf, ")");
                    let orig_argv_buf = argv_buf;
                    for (let i = 0; i < args.length; i++) {
                        buffer.setUint32(argv, argv_buf, true);
                        argv += 4;
                        let arg = new TextEncoder("utf-8").encode(args[i]);
                        buffer8.set(arg, argv_buf);
                        buffer.setUint8(argv_buf + arg.length, 0);
                        argv_buf += arg.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_argv_buf, argv_buf)));
                    return 0;
                },

                environ_sizes_get(environ_count, environ_size) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("environ_sizes_get(", environ_count, ", ", environ_size, ")");
                    buffer.setUint32(environ_count, env.length, true);
                    let buf_size = 0;
                    for (let environ of env) {
                        buf_size += environ.length + 1;
                    }
                    buffer.setUint32(environ_size, buf_size, true);
                    console.log(buffer.getUint32(environ_count, true), buffer.getUint32(environ_size, true));
                    return 0;
                },
                environ_get(environ, environ_buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("environ_get(", environ, ", ", environ_buf, ")");
                    let orig_environ_buf = environ_buf;
                    for (let i = 0; i < env.length; i++) {
                        buffer.setUint32(environ, environ_buf, true);
                        environ += 4;
                        let e = new TextEncoder("utf-8").encode(env[i]);
                        buffer8.set(e, environ_buf);
                        buffer.setUint8(environ_buf + e.length, 0);
                        environ_buf += e.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_environ_buf, environ_buf)));
                    return 0;
                },

                clock_time_get(id, precision, time) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("clock_time_get(", id, ", ", precision, ", ", time, ")");
                    buffer.setBigUint64(time, 0n, true);
                    return 0;
                },
                fd_close() { console.log("fd_close"); },
                fd_filestat_get(fd, buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.warn("fd_filestat_get(", fd, ", ", buf, ")");
                    if (fds[fd] != undefined) {
                        let stat = fds[fd].stat();
                        buffer.setBigUint64(buf, stat.dev, true);
                        buffer.setBigUint64(buf + 8, stat.ino, true);
                        buffer.setUint8(buf + 16, stat.file_type);
                        buffer.setBigUint64(buf + 24, stat.nlink, true);
                        buffer.setBigUint64(buf + 32, stat.size, true);
                        buffer.setBigUint64(buf + 38, stat.atim, true);
                        buffer.setBigUint64(buf + 46, stat.mtim, true);
                        buffer.setBigUint64(buf + 52, stat.ctim, true);
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_read(fd, iovs_ptr, iovs_len, nread_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("fd_read(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nread_ptr, ")");
                    if (fds[fd] != undefined) {
                        buffer.setUint32(nread_ptr, 0, true);
                        for (let i = 0; i < iovs_len; i++) {
                            let [ptr, len] = [buffer.getUint32(iovs_ptr + 8 * i, true), buffer.getUint32(iovs_ptr + 8 * i + 4, true)];
                            let [data, err] = fds[fd].read(len);
                            if (err != 0) {
                                return err;
                            }
                            buffer8.set(data, ptr);
                            buffer.setUint32(nread_ptr, buffer.getUint32(nread_ptr, true) + data.length, true);
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_readdir(fd, buf, buf_len, cookie, bufused) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.warn("fd_readdir(", fd, ", ", buf, ", ", buf_len, ", ", cookie, ", ", bufused, ")");
                    // 8 ,  3408816 ,  128 ,  0n ,  1032332
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        buffer.setUint32(bufused, 0, true);

                        console.log(cookie, Object.keys(fds[fd].directory).slice(Number(cookie)));
                        if (cookie >= BigInt(Object.keys(fds[fd].directory).length)) {
                            console.log("end of dir");
                            return 0;
                        }
                        let next_cookie = cookie + 1n;
                        for (let name of Object.keys(fds[fd].directory).slice(Number(cookie))) {
                            let entry = fds[fd].directory[name];
                            console.log(name, entry);
                            let encoded_name = new TextEncoder("utf-8").encode(name);

                            let offset = 24 + encoded_name.length;

                            if ((buf_len - buffer.getUint32(bufused, true)) < offset) {
                                console.log("too small buf");
                                break;
                            } else {
                                console.log("next_cookie =", next_cookie, buf);
                                buffer.setBigUint64(buf, next_cookie, true);
                                next_cookie += 1n;
                                buffer.setBigUint64(buf + 8, 1n, true); // inode
                                buffer.setUint32(buf + 16, encoded_name.length, true);
                                buffer.setUint8(buf + 20, entry.file_type);
                                buffer8.set(encoded_name, buf + 24);
                                console.log("buffer =", buffer8.slice(buf, buf + offset));
                                buf += offset;
                                buffer.setUint32(bufused, buffer.getUint32(bufused, true) + offset, true);
                                console.log();
                            }
                        }
                        console.log("used =", buffer.getUint32(bufused, true));
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_seek() { console.log("fd_seek"); },
                fd_write(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("fd_write(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nwritten_ptr, ")");
                    if (fds[fd] != undefined) {
                        buffer.setUint32(nwritten_ptr, 0, true);
                        for (let i = 0; i < iovs_len; i++) {
                            let [ptr, len] = [buffer.getUint32(iovs_ptr + 8 * i, true), buffer.getUint32(iovs_ptr + 8 * i + 4, true)];
                            let err = fds[fd].write(buffer8.slice(ptr, ptr + len));
                            if (err != 0) {
                                return err;
                            }
                            buffer.setUint32(nwritten_ptr, buffer.getUint32(nwritten_ptr, true) + len, true);
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_create_directory() { console.log("path_create_directory"); },
                path_filestat_get(fd, flags, path_ptr, path_len, buf) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.warn("path_filestat_get(", fd, ", ", flags, ", ", path_ptr, ", ", path_len, ", ", buf, ")");
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log("file =", path);
                        let entry = fds[fd].get_entry_for_path(path);
                        if (entry == null) {
                            return -1;
                        }
                        // FIXME write filestat_t
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_link() { console.log("path_link"); },
                path_open(fd, dirflags, path_ptr, path_len, oflags, fs_rights_base, fs_rights_inheriting, fdflags, opened_fd_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    console.log("path_open(",
                        dirflags, ", ",
                        path_ptr, ", ",
                        path_len, ", ",
                        oflags, ", ",
                        fs_rights_base, ", ",
                        fs_rights_inheriting, ", ",
                        fdflags, ", ",
                        opened_fd_ptr, ")",
                    );
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log(path);
                        let entry = fds[fd].get_entry_for_path(path);
                        if (entry == null) {
                            return -1;
                        }
                        fds.push(entry.open());
                        let opened_fd = fds.length - 1;
                        buffer.setUint32(opened_fd_ptr, opened_fd, true);
                    } else {
                        return -1;
                    }
                },
                path_readlink() { console.log("path_readlink"); },
                path_remove_directory() { console.log("path_remove_directory"); },
                path_rename() { console.log("path_rename"); },
                path_unlink_file() { console.log("path_unlink_file"); },
                sched_yield() { console.log("sched_yield"); },
                fd_prestat_get(fd, buf_ptr) {
                    let buffer = new DataView(inst.exports.memory.buffer);
                    console.log("fd_prestat_get(", fd, ", ", buf_ptr, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        const PREOPEN_TYPE_DIR = 0;
                        buffer.setUint32(buf_ptr, PREOPEN_TYPE_DIR, true);
                        buffer.setUint32(buf_ptr + 4, fds[fd].prestat_name.length);
                        return 0;
                    } else {
                        return -1;
                    }

                },
                fd_prestat_dir_name(fd, path_ptr, path_len) {
                    console.log("fd_prestat_dir_name(", fd, ", ", path_ptr, ", ", path_len, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        buffer8.set(fds[fd].prestat_name, path_ptr);
                        return 0;
                    } else {
                        return -1;
                    }
                },
            }
        });
        document.body.innerText = "Executing\n";
        console.log(inst.exports);
        try { inst.exports._start(); } catch (e) { }
        inst.exports.main();
        document.body.innerText += "\nDone";
    })();
</script>
