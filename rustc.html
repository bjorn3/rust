<meta charset="utf-8">
<script type="module">
    (async function () {
        document.body.style.fontFamily = "monospace";
        document.body.style.whiteSpace = "pre";
        document.body.innerText = "Downloading";
        let wasm = await WebAssembly.compileStreaming(fetch("/target/wasm32-wasi/release/rustc_binary.wasm"));
        document.body.innerText = "Instantiating";

        function fd_err() {
            return -1;
        }

        function read_stdio() {
            throw "unimplemented read_stdio";
        }

        function write_stdio(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }

        let args = ["rustc", "./hello.rs", "--sysroot", "/sysroot"];
        let fds = [
            {
                read: read_stdio,
                write: fd_err,
            },
            {
                read: fd_err,
                write: write_stdio,
            },
            {
                read: fd_err,
                write: write_stdio,
            },
            {
                prestat_name: new TextEncoder("utf-8").encode("."),
                directory: {
                    "hello.rs": function() {
                        let fd = fds.length;
                        let file_pos = 0;
                        let data = new TextEncoder("utf-8").encode("fn a");
                        fds.push({
                            read: function(len) {
                                if (file_pos < data.length) {
                                    let slice = data.slice(file_pos, file_pos + len);
                                    file_pos += slice.length;
                                    return [slice, 0];
                                } else {
                                    return [[], 0];
                                }
                            },
                            write: fd_err,
                        });
                        return fd;
                    }
                }
            },
            {
                prestat_name: new TextEncoder("utf-8").encode("/sysroot"),
                directory: {}
            },
        ]

        let inst = await WebAssembly.instantiate(wasm, {
            "wasi_snapshot_preview1": {
                proc_exit() { console.log("proc_exit"); },
                random_get() { console.log("random_get"); },
                args_sizes_get(argc, argv_buf_size) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("args_sizes_get(", argc, ", ", argv_buf_size, ")");
                    buffer32[argc / 4] = args.length;
                    let buf_size = 0;
                    for (let arg of args) {
                        buf_size += arg.length + 1;
                    }
                    buffer32[argv_buf_size / 4] = buf_size;
                    console.log(buffer32[argc / 4], buffer32[argv_buf_size / 4]);
                    return 0;
                },
                args_get(argv, argv_buf) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("args_get(", argv, ", ", argv_buf, ")");
                    let orig_argv_buf = argv_buf;
                    for (let i = 0; i < args.length; i++) {
                        buffer32[argv / 4] = argv_buf;
                        argv += 4;
                        let arg = new TextEncoder("utf-8").encode(args[i]);
                        buffer8.set(arg, argv_buf);
                        buffer8[argv_buf + arg.length] = 0;
                        argv_buf += arg.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_argv_buf, argv_buf)));
                    return 0;
                },
                clock_time_get() { console.log("clock_time_get"); return 0; },
                fd_close() { console.log("fd_close"); },
                fd_filestat_get() { console.log("fd_filestat_get"); },
                fd_read(fd, iovs_ptr, iovs_len, nread_ptr) {
                    console.log("fd_read(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nread_ptr, ")");
                    if (fds[fd] != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        buffer32[nread_ptr / 4] = 0;
                        for (let i = 0; i < iovs_len; i++) {
                            let [ptr, len] = [buffer32[iovs_ptr / 4 + 2 * i], buffer32[iovs_ptr / 4 + 2 * i + 1]];
                            let [data, err] = fds[fd].read(len);
                            if (err != 0) {
                                return err;
                            }
                            buffer8.set(data, ptr);
                            buffer32[nread_ptr / 4] += data.length;
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_readdir() { console.log("fd_readdir"); },
                fd_seek() { console.log("fd_seek"); },
                fd_write(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                    console.log("fd_write(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nwritten_ptr, ")");
                    if (fds[fd] != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        buffer32[nwritten_ptr / 4] = 0;
                        for (let i = 0; i < iovs_len; i++) {
                            let [ptr, len] = [buffer32[iovs_ptr / 4 + 2 * i], buffer32[iovs_ptr / 4 + 2 * i + 1]];
                            let err = fds[fd].write(buffer8.slice(ptr, ptr + len));
                            if (err != 0) {
                                return err;
                            }
                            buffer32[nwritten_ptr / 4] += len;
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_create_directory() { console.log("path_create_directory"); },
                path_filestat_get(fd, buf) {
                    console.log("path_filestat_get(", fd, ", ", buf, ")");
                    return -1;
                },
                path_link() { console.log("path_link"); },
                path_open(fd, dirflags, path_ptr, path_len, oflags, fs_rights_base, fs_rights_inheriting, fdflags, opened_fd_ptr) {
                    console.log("path_open(",
                        dirflags, ", ",
                        path_ptr, ", ",
                        path_len, ", ",
                        oflags, ", ",
                        fs_rights_base, ", ",
                        fs_rights_inheriting, ", ",
                        fdflags, ", ",
                        opened_fd_ptr, ")",
                    );
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log(path);
                        let opened_fd = fd;
                        for (let component of path.split("/")) {
                            if (fds[fd].directory[component] != undefined) {
                                opened_fd = fds[fd].directory[component]();
                            } else {
                                return -3;
                            }
                        }
                        buffer32[opened_fd_ptr/4] = opened_fd;
                    } else {
                        return -1;
                    }
                },
                path_readlink() { console.log("path_readlink"); },
                path_remove_directory() { console.log("path_remove_directory"); },
                path_rename() { console.log("path_rename"); },
                path_unlink_file() { console.log("path_unlink_file"); },
                sched_yield() { console.log("sched_yield"); },
                fd_prestat_get(fd, buf_ptr) {
                    console.log("fd_prestat_get(", fd, ", ", buf_ptr, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        const PREOPEN_TYPE_DIR = 0;
                        buffer32[buf_ptr / 4] = PREOPEN_TYPE_DIR;
                        buffer32[buf_ptr / 4 + 1] = fds[fd].prestat_name.length + 1;
                        return 0;
                    } else {
                        return -1;
                    }

                },
                fd_prestat_dir_name(fd, path_ptr, path_len) {
                    console.log("fd_prestat_dir_name(", fd, ", ", path_ptr, ", ", path_len, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        buffer8.set(fds[fd].prestat_name, path_ptr);
                        buffer8[path_ptr + fds[fd].prestat_name, 0];
                        return 0;
                    } else {
                        return -1;
                    }
                },
                environ_sizes_get() { console.log("environ_sizes_get"); },
                environ_get() { console.log("environ_get"); }
            }
        });
        document.body.innerText = "Executing\n";
        console.log(inst.exports);
        try { inst.exports._start(); } catch (e) { }
        inst.exports.main();
        document.body.innerText = "Done";
    })();
</script>
