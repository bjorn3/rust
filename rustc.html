<meta charset="utf-8">
<script type="module">
    (async function () {
        document.body.style.fontFamily = "monospace";
        document.body.style.whiteSpace = "pre";
        document.body.innerText = "Downloading";
        let wasm = await WebAssembly.compileStreaming(fetch("/target/wasm32-wasi/release/rustc_binary.wasm"));
        document.body.innerText = "Instantiating";

        const FILETYPE_UNKNOWN = 0;
        const FILETYPE_DIRECTORY = 3;
        const FILETYPE_REGULAR_FILE = 4;

        function write_le_u32(buf, ptr, num) {
            buf[ptr] = num;
            buf[ptr+1] = num >> 8;
            buf[ptr+2] = num >> 16;
            buf[ptr+3] = num >> 24;
        }

        function write_le_u64(buf, ptr, num) {
            buf[ptr] = Number(num);
            buf[ptr+1] = Number(num >> 8n);
            buf[ptr+2] = Number(num >> 16n);
            buf[ptr+3] = Number(num >> 24n);
            buf[ptr+4] = Number(num >> 32n);
            buf[ptr+5] = Number(num >> 40n);
            buf[ptr+6] = Number(num >> 48n);
            buf[ptr+7] = Number(num >> 56n);
        }

        function fd_err() {
            return -1;
        }

        function read_stdio() {
            throw "unimplemented read_stdio";
        }

        function write_stdio(buffer) {
            document.body.innerText += new TextDecoder("utf-8").decode(buffer);
            return 0;
        }

        function new_readonly_file(data) {
            let file_pos = 0;
            return {
                file_type: FILETYPE_REGULAR_FILE,
                read: function (len) {
                    if (file_pos < data.length) {
                        let slice = data.slice(file_pos, file_pos + len);
                        file_pos += slice.length;
                        return [slice, 0];
                    } else {
                        return [[], 0];
                    }
                },
                write: fd_err,
            };
        }

        function new_directory(name, contents) {
            return {
                file_type: FILETYPE_DIRECTORY,
                prestat_name: new TextEncoder("utf-8").encode(name),
                directory: contents,
            };
        }

        let args = ["rustc", "./hello.rs", "--sysroot", "/sysroot", "--target", "x86_64-unknown-linux-gnu"];
        let env = ["RUSTC_LOG=trace"];
        let fds = [
            {
                file_type: FILETYPE_UNKNOWN,
                read: read_stdio,
                write: fd_err,
            },
            {
                file_type: FILETYPE_UNKNOWN,
                read: fd_err,
                write: write_stdio,
            },
            {
                file_type: FILETYPE_UNKNOWN,
                read: fd_err,
                write: write_stdio,
            },
            new_directory(".", {
                "hello.rs": new_readonly_file(new TextEncoder("utf-8").encode("#![no_std]")),
            }),
            new_directory("/sysroot", {
                "lib": new_directory("lib", {
                    "rustlib": new_directory("rustlib", {
                        "wasm32-wasi": new_directory("wasm32-wasi", {
                            "lib": new_directory("lib", {}),
                        }),
                        "x86_64-unknown-linux-gnu": new_directory("x86_64-unknown-linux-gnu", {
                            "lib": new_directory("lib", {
                                "libcore-b4a7d25c83ac0d14.rlib": new_readonly_file(await fetch("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcore-b4a7d25c83ac0d14.rlib")),
                                "libcore-b4a7d25c83ac0d14.rmeta": new_readonly_file(await fetch("/sysroot/lib/rustlib/x86_64-unknown-linux-gnu/lib/libcore-b4a7d25c83ac0d14.rmeta")),
                            }),
                        }),
                    }),
                }),
            }),
        ];

        let inst = await WebAssembly.instantiate(wasm, {
            "wasi_snapshot_preview1": {
                proc_exit() { console.log("proc_exit"); },
                random_get() { console.log("random_get"); },
                args_sizes_get(argc, argv_buf_size) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("args_sizes_get(", argc, ", ", argv_buf_size, ")");
                    buffer32[argc / 4] = args.length;
                    let buf_size = 0;
                    for (let arg of args) {
                        buf_size += arg.length + 1;
                    }
                    buffer32[argv_buf_size / 4] = buf_size;
                    console.log(buffer32[argc / 4], buffer32[argv_buf_size / 4]);
                    return 0;
                },
                args_get(argv, argv_buf) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("args_get(", argv, ", ", argv_buf, ")");
                    let orig_argv_buf = argv_buf;
                    for (let i = 0; i < args.length; i++) {
                        buffer32[argv / 4] = argv_buf;
                        argv += 4;
                        let arg = new TextEncoder("utf-8").encode(args[i]);
                        buffer8.set(arg, argv_buf);
                        buffer8[argv_buf + arg.length] = 0;
                        argv_buf += arg.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_argv_buf, argv_buf)));
                    return 0;
                },

                environ_sizes_get(environ_count, environ_size) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("environ_sizes_get(", environ_count, ", ", environ_size, ")");
                    buffer32[environ_count / 4] = env.length;
                    let buf_size = 0;
                    for (let environ of env) {
                        buf_size += environ.length + 1;
                    }
                    buffer32[environ_size / 4] = buf_size;
                    console.log(buffer32[environ_count / 4], buffer32[environ_size / 4]);
                    return 0;
                },
                environ_get(environ, environ_buf) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("environ_get(", environ, ", ", environ_buf, ")");
                    let orig_environ_buf = environ_buf;
                    for (let i = 0; i < env.length; i++) {
                        buffer32[environ / 4] = environ_buf;
                        environ += 4;
                        let e = new TextEncoder("utf-8").encode(env[i]);
                        buffer8.set(e, environ_buf);
                        buffer8[environ_buf + e.length] = 0;
                        environ_buf += e.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_environ_buf, environ_buf)));
                    return 0;
                },

                clock_time_get() { console.log("clock_time_get"); return 0; },
                fd_close() { console.log("fd_close"); },
                fd_filestat_get() { console.log("fd_filestat_get"); },
                fd_read(fd, iovs_ptr, iovs_len, nread_ptr) {
                    console.log("fd_read(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nread_ptr, ")");
                    if (fds[fd] != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        buffer32[nread_ptr / 4] = 0;
                        for (let i = 0; i < iovs_len; i++) {
                            let [ptr, len] = [buffer32[iovs_ptr / 4 + 2 * i], buffer32[iovs_ptr / 4 + 2 * i + 1]];
                            let [data, err] = fds[fd].read(len);
                            if (err != 0) {
                                return err;
                            }
                            buffer8.set(data, ptr);
                            buffer32[nread_ptr / 4] += data.length;
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_readdir(fd, buf, buf_len, cookie, bufused) {
                    console.warn("fd_readdir(", fd, ", ", buf, ", ", buf_len, ", ", cookie, ", ", bufused, ")");
                    // 8 ,  3408816 ,  128 ,  0n ,  1032332
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);

                        buffer32[bufused / 4] = 0;

                        console.log(cookie, Object.keys(fds[fd].directory).slice(Number(cookie)));
                        if (cookie >= BigInt(Object.keys(fds[fd].directory).length)) {
                            console.log("end of dir");
                            return 0;
                        }
                        let next_cookie = cookie + 1n;
                        for (let name of Object.keys(fds[fd].directory).slice(Number(cookie))) {
                            let entry = fds[fd].directory[name];
                            console.log(name, entry);
                            let encoded_name = new TextEncoder("utf-8").encode(name);

                            let offset = 24 + encoded_name.length;

                            if ((buf_len - buffer32[bufused / 4]) < offset) {
                                console.log("too small buf");
                                break;
                            } else {
                                console.log("next_cookie =", next_cookie, buf);
                                write_le_u64(buffer8, buf, next_cookie);
                                next_cookie += 1n;
                                write_le_u64(buffer8, buf + 8, 1n); // inode
                                write_le_u32(buffer8, buf + 16, encoded_name.length); // name
                                buffer8[buf + 20] = entry.file_type;
                                buffer8.set(encoded_name, buf + 24);
                                console.log("buffer =", buffer8.slice(buf, buf + offset));
                                buf += offset;
                                buffer32[bufused / 4] += offset;
                                console.log();
                            }
                        }
                        console.log("used =", buffer32[bufused / 4]);
                        return 0;
                    } else {
                        return -1;
                    }
                },
                fd_seek() { console.log("fd_seek"); },
                fd_write(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                    console.log("fd_write(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nwritten_ptr, ")");
                    if (fds[fd] != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        buffer32[nwritten_ptr / 4] = 0;
                        for (let i = 0; i < iovs_len; i++) {
                            let [ptr, len] = [buffer32[iovs_ptr / 4 + 2 * i], buffer32[iovs_ptr / 4 + 2 * i + 1]];
                            let err = fds[fd].write(buffer8.slice(ptr, ptr + len));
                            if (err != 0) {
                                return err;
                            }
                            buffer32[nwritten_ptr / 4] += len;
                        }
                        return 0;
                    } else {
                        return -1;
                    }
                },
                path_create_directory() { console.log("path_create_directory"); },
                path_filestat_get(fd, buf) {
                    console.log("path_filestat_get(", fd, ", ", buf, ")");
                    return -1;
                },
                path_link() { console.log("path_link"); },
                path_open(fd, dirflags, path_ptr, path_len, oflags, fs_rights_base, fs_rights_inheriting, fdflags, opened_fd_ptr) {
                    console.log("path_open(",
                        dirflags, ", ",
                        path_ptr, ", ",
                        path_len, ", ",
                        oflags, ", ",
                        fs_rights_base, ", ",
                        fs_rights_inheriting, ", ",
                        fdflags, ", ",
                        opened_fd_ptr, ")",
                    );
                    if (fds[fd] != undefined && fds[fd].directory != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        let path = new TextDecoder("utf-8").decode(buffer8.slice(path_ptr, path_ptr + path_len));
                        console.log(path);
                        let opened_fd = fd;
                        for (let component of path.split("/")) {
                            if (component == "") break;
                            if (fds[opened_fd].directory[component] != undefined) {
                                fds.push(fds[opened_fd].directory[component]);
                                opened_fd = fds.length - 1;
                            } else {
                                console.log(component);
                                return -3;
                            }
                        }
                        buffer32[opened_fd_ptr / 4] = opened_fd;
                    } else {
                        return -1;
                    }
                },
                path_readlink() { console.log("path_readlink"); },
                path_remove_directory() { console.log("path_remove_directory"); },
                path_rename() { console.log("path_rename"); },
                path_unlink_file() { console.log("path_unlink_file"); },
                sched_yield() { console.log("sched_yield"); },
                fd_prestat_get(fd, buf_ptr) {
                    console.log("fd_prestat_get(", fd, ", ", buf_ptr, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        const PREOPEN_TYPE_DIR = 0;
                        buffer32[buf_ptr / 4] = PREOPEN_TYPE_DIR;
                        buffer32[buf_ptr / 4 + 1] = fds[fd].prestat_name.length + 1;
                        return 0;
                    } else {
                        return -1;
                    }

                },
                fd_prestat_dir_name(fd, path_ptr, path_len) {
                    console.log("fd_prestat_dir_name(", fd, ", ", path_ptr, ", ", path_len, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        buffer8.set(fds[fd].prestat_name, path_ptr);
                        buffer8[path_ptr + fds[fd].prestat_name, 0];
                        return 0;
                    } else {
                        return -1;
                    }
                },
            }
        });
        document.body.innerText = "Executing\n";
        console.log(inst.exports);
        try { inst.exports._start(); } catch (e) { }
        inst.exports.main();
        document.body.innerText = "Done";
    })();
</script>
