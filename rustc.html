<meta charset="utf-8">
<script type="module">
    (async function () {
        document.body.innerText = "Downloading";
        let wasm = await WebAssembly.compileStreaming(fetch("/target/wasm32-wasi/release/rustc_binary.wasm"));
        document.body.innerText = "Instantiating";

        function fd_err() {
            return -1;
        }

        function read_stdio() {
            throw "unimplemented read_stdio";
        }

        function write_stdio(buffer, fd, iovs_ptr, iovs_len, nwritten_ptr) {
            let buffer8 = new Uint8Array(buffer);
            let buffer32 = new Uint32Array(buffer);
            buffer32[nwritten_ptr / 4] = 0;
            for (let i = 0; i < iovs_len; i++) {
                let [ptr, len] = [buffer32[iovs_ptr / 4 + 2 * i], buffer32[iovs_ptr / 4 + 2 * i + 1]];
                document.body.innerText += new TextDecoder("utf-8").decode(buffer8.slice(ptr, ptr + len));
                console.log(ptr, len);

                buffer32[nwritten_ptr / 4] += len;
            }
            return 0; // errno
        }

        let args = ["rustc", "./hello.rs", "--sysroot", "/sysroot"];
        let fds = [
            {
                fd_read: read_stdio,
                fd_write: fd_err,
            },
            {
                fd_read: fd_err,
                fd_write: write_stdio,
            },
            {
                fd_read: fd_err,
                fd_write: write_stdio,
            },
            {
                prestat_name: new TextEncoder("utf-8").encode("."),
            },
            {
                prestat_name: new TextEncoder("utf-8").encode("/sysroot"),
            },
        ]

        let inst = await WebAssembly.instantiate(wasm, {
            "wasi_snapshot_preview1": {
                proc_exit() { console.log("proc_exit"); },
                random_get() { console.log("random_get"); },
                args_sizes_get(argc, argv_buf_size) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("args_sizes_get(", argc, ", ", argv_buf_size, ")");
                    buffer32[argc / 4] = args.length;
                    let buf_size = 0;
                    for (let arg of args) {
                        buf_size += arg.length + 1;
                    }
                    buffer32[argv_buf_size / 4] = buf_size;
                    console.log(buffer32[argc / 4], buffer32[argv_buf_size / 4]);
                    return 0;
                },
                args_get(argv, argv_buf) {
                    let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                    let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                    console.log("args_get(", argv, ", ", argv_buf, ")");
                    let orig_argv_buf = argv_buf;
                    for (let i = 0; i < args.length; i++) {
                        buffer32[argv / 4] = argv_buf;
                        argv += 4;
                        let arg = new TextEncoder("utf-8").encode(args[i]);
                        buffer8.set(arg, argv_buf);
                        buffer8[argv_buf + arg.length] = 0;
                        argv_buf += arg.length + 1;
                    }
                    console.log(new TextDecoder("utf-8").decode(buffer8.slice(orig_argv_buf, argv_buf)));
                    return 0;
                },
                clock_time_get() { console.log("clock_time_get"); return 0; },
                fd_close() { console.log("fd_close"); },
                fd_filestat_get() { console.log("fd_filestat_get"); },
                fd_read(fd, iovs_ptr, iovs_len, nread_ptr) {
                    console.log("fd_read(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nread_ptr, ")");
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_read(inst.exports.memory.buffer, fd, iovs_ptr, iovs_len, nread_ptr);
                    } else {
                        return -1;
                    }
                },
                fd_readdir() { console.log("fd_readdir"); },
                fd_seek() { console.log("fd_seek"); },
                fd_write(fd, iovs_ptr, iovs_len, nwritten_ptr) {
                    console.log("fd_write(", fd, ", ", iovs_ptr, ", ", iovs_len, ", ", nwritten_ptr, ")");
                    if (fds[fd] != undefined) {
                        return fds[fd].fd_write(inst.exports.memory.buffer, fd, iovs_ptr, iovs_len, nwritten_ptr);
                    } else {
                        return -1;
                    }
                },
                path_create_directory() { console.log("path_create_directory"); },
                path_filestat_get(fd, buf) {
                    console.log("path_filestat_get(", fd, ", ", buf, ")");
                    return -1;
                },
                path_link() { console.log("path_link"); },
                path_open() { console.log("path_open"); return 1; },
                path_readlink() { console.log("path_readlink"); },
                path_remove_directory() { console.log("path_remove_directory"); },
                path_rename() { console.log("path_rename"); },
                path_unlink_file() { console.log("path_unlink_file"); },
                sched_yield() { console.log("sched_yield"); },
                fd_prestat_get(fd, buf_ptr) {
                    console.log("fd_prestat_get(", fd, ", ", buf_ptr, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        let buffer32 = new Uint32Array(inst.exports.memory.buffer);
                        const PREOPEN_TYPE_DIR = 0;
                        buffer32[buf_ptr / 4] = PREOPEN_TYPE_DIR;
                        buffer32[buf_ptr / 4 + 1] = fds[fd].prestat_name.length + 1;
                        return 0;
                    } else {
                        return -1;
                    }

                },
                fd_prestat_dir_name(fd, path_ptr, path_len) {
                    console.log("fd_prestat_dir_name(", fd, ", ", path_ptr, ", ", path_len, ")");
                    if (fds[fd] != undefined && fds[fd].prestat_name != undefined) {
                        let buffer8 = new Uint8Array(inst.exports.memory.buffer);
                        buffer8.set(fds[fd].prestat_name, path_ptr);
                        buffer8[path_ptr + fds[fd].prestat_name, 0];
                        return 0;
                    } else {
                        return -1;
                    }
                },
                environ_sizes_get() { console.log("environ_sizes_get"); },
                environ_get() { console.log("environ_get"); }
            }
        });
        document.body.innerText = "Executing\n";
        console.log(inst.exports);
        try { inst.exports._start(); } catch (e) { }
        inst.exports.main();
        document.body.innerText = "Done";
    })();
</script>
